"use strict";
/**
 * A collection of static functions that deals with transforming game states to
 * and from serialize-able objects when communicating between client <--> sever
 */
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("~/utils");
const constants_1 = require("./constants");
const game_1 = require("./game/");
/**
 * Checks if a given object is a game object reference (has only an id key set).
 *
 * @param obj - The object to check.
 * @returns True if the object is a game object reference
 */
function isGameObjectReference(obj) {
    return utils_1.isEmptyExceptFor(obj, "id");
}
exports.isGameObjectReference = isGameObjectReference;
/**
 * Serializes something about a game so it is safe to send over a socket.
 * This is required to avoid cycles and send lists correctly.
 *
 * @param state The variable you want to serialize.
 * Anything in the game should be Serializable, numbers, strings,
 * BaseGameObjects, dicts, lists, nulls, etc.
 * @returns The state, serialized. It will never be the same object if it is an
 * object ({} or []).
 */
function serialize(state) {
    let serializing = state;
    if (!utils_1.isObject(serializing)) {
        // not an object, no need to further serialize
        return serializing;
    }
    else if (serializing instanceof game_1.BaseGameObject) {
        // no need to serialize this whole thing
        return { id: serializing.id };
    }
    if (serializing instanceof Map) {
        serializing = utils_1.mapToObject(serializing);
    }
    const serialized = {};
    if (serializing instanceof Array) {
        // Record the length, we never send arrays in serialized states because
        // you can't tell when they change in size without sending all the
        // elements.
        serialized[constants_1.SHARED_CONSTANTS.DELTA_LIST_LENGTH] = serializing.length;
    }
    for (const [key, value] of Object.entries(serializing)) {
        serialized[key] = serialize(value);
    }
    return serialized; // it is actually TypedObject<Serialized> but that gets mad
}
exports.serialize = serialize;
/**
 * Un-serializes data from a game client.
 *
 * @param data The data to un-serialize.
 * @param game The game to lookup game objects in for game object references in
 * data.
 * @param dataTypeConverter The function to convert the un-serialized value
 * once found.
 * @returns The data now un-serialized, will create new objects instead of
 * reusing objects.
 */
function unSerialize(data, game, dataTypeConverter) {
    if (utils_1.isObject(data) && game) {
        const result = Array.isArray(data)
            ? [] // numbers are implicitly converted to strings which works, kinda hack-y
            : {};
        for (const [key, value] of Object.entries(data)) {
            if (utils_1.isObject(value)) {
                result[key] = isGameObjectReference(value)
                    ? game.gameObjects[value.id] // it's a tracked game object
                    : unSerialize(value, game);
            }
            else {
                result[key] = value;
            }
        }
        return result;
    }
    if (dataTypeConverter) {
        return dataTypeConverter(data);
    }
    return data; // it is a primitive, which are serializeable
}
exports.unSerialize = unSerialize;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VyaWFsaXplci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL3NlcmlhbGl6ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7QUFFSCxtQ0FDd0M7QUFDeEMsMkNBQStDO0FBQy9DLGtDQUFtRDtBQStDbkQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixxQkFBcUIsQ0FDakMsR0FBNkI7SUFLN0IsT0FBTyx3QkFBZ0IsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDdkMsQ0FBQztBQVBELHNEQU9DO0FBRUQ7Ozs7Ozs7OztHQVNHO0FBQ0gsU0FBZ0IsU0FBUyxDQUFDLEtBQWM7SUFDcEMsSUFBSSxXQUFXLEdBQUcsS0FBSyxDQUFDO0lBQ3hCLElBQUksQ0FBQyxnQkFBUSxDQUFDLFdBQVcsQ0FBQyxFQUFFO1FBQ3hCLDhDQUE4QztRQUM5QyxPQUFPLFdBQTZCLENBQUM7S0FDeEM7U0FDSSxJQUFJLFdBQVcsWUFBWSxxQkFBYyxFQUFFO1FBQzVDLHdDQUF3QztRQUN4QyxPQUFPLEVBQUUsRUFBRSxFQUFFLFdBQVcsQ0FBQyxFQUFFLEVBQUUsQ0FBQztLQUNqQztJQUVELElBQUksV0FBVyxZQUFZLEdBQUcsRUFBRTtRQUM1QixXQUFXLEdBQUcsbUJBQVcsQ0FBQyxXQUFXLENBQUMsQ0FBQztLQUMxQztJQUVELE1BQU0sVUFBVSxHQUFrQixFQUFFLENBQUM7SUFDckMsSUFBSSxXQUFXLFlBQVksS0FBSyxFQUFFO1FBQzlCLHVFQUF1RTtRQUN2RSxrRUFBa0U7UUFDbEUsWUFBWTtRQUNaLFVBQVUsQ0FBQyw0QkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUM7S0FDdkU7SUFFRCxLQUFLLE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUE0QixDQUFDLEVBQUU7UUFDckUsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUN0QztJQUVELE9BQU8sVUFBZ0IsQ0FBQyxDQUFDLDJEQUEyRDtBQUN4RixDQUFDO0FBNUJELDhCQTRCQztBQUVEOzs7Ozs7Ozs7O0dBVUc7QUFDSCxTQUFnQixXQUFXLENBQ3ZCLElBQWEsRUFDYixJQUFjLEVBQ2QsaUJBQXVDO0lBRXZDLElBQUksZ0JBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUU7UUFDeEIsTUFBTSxNQUFNLEdBQWtCLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1lBQzdDLENBQUMsQ0FBQyxFQUFRLENBQUMsd0VBQXdFO1lBQ25GLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFFVCxLQUFLLE1BQU0sQ0FBRSxHQUFHLEVBQUUsS0FBSyxDQUFFLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUMvQyxJQUFJLGdCQUFRLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQ2pCLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUM7b0JBQ3RDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyw2QkFBNkI7b0JBQzFELENBQUMsQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO2FBQ2xDO2lCQUNJO2dCQUNELE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7YUFDdkI7U0FDSjtRQUVELE9BQU8sTUFBc0IsQ0FBQztLQUNqQztJQUVELElBQUksaUJBQWlCLEVBQUU7UUFDbkIsT0FBTyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNsQztJQUVELE9BQU8sSUFBUyxDQUFDLENBQUMsNkNBQTZDO0FBQ25FLENBQUM7QUE3QkQsa0NBNkJDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2Ygc3RhdGljIGZ1bmN0aW9ucyB0aGF0IGRlYWxzIHdpdGggdHJhbnNmb3JtaW5nIGdhbWUgc3RhdGVzIHRvXG4gKiBhbmQgZnJvbSBzZXJpYWxpemUtYWJsZSBvYmplY3RzIHdoZW4gY29tbXVuaWNhdGluZyBiZXR3ZWVuIGNsaWVudCA8LS0+IHNldmVyXG4gKi9cblxuaW1wb3J0IHsgSW1tdXRhYmxlLCBpc0VtcHR5RXhjZXB0Rm9yLCBpc09iamVjdCwgbWFwVG9PYmplY3QsIFR5cGVkT2JqZWN0LFxuICAgICAgICAgVW5rbm93bk9iamVjdCB9IGZyb20gXCJ+L3V0aWxzXCI7XG5pbXBvcnQgeyBTSEFSRURfQ09OU1RBTlRTIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBCYXNlR2FtZSwgQmFzZUdhbWVPYmplY3QgfSBmcm9tIFwiLi9nYW1lL1wiO1xuXG4vKiogVGhlIG5hbWVzIG9mIHR5cGVzIHRoYXQgYXJlIGFjY2VwdGVkIGZyb20gY3JlZXIgdHlwZXMuICovXG5leHBvcnQgdHlwZSBTZXJpYWxpemFibGVUeXBlTmFtZSA9XG4gICAgXCJzdHJpbmdcIiB8XG4gICAgXCJmbG9hdFwiIHxcbiAgICBcImludFwiIHxcbiAgICBcImJvb2xlYW5cIiB8XG4gICAgXCJkaWN0aW9uYXJ5XCIgfFxuICAgIFwibGlzdFwiIHxcbiAgICBcImdhbWVPYmplY3RcIiB8XG4gICAgXCJ2b2lkXCJcbjtcblxuLyoqIEJhc2UgdHlwZXMgdGhhdCBhcmUgc2VyaWFsaXphYmxlICovXG50eXBlIEJhc2VTZXJpYWxpemFibGUgPVxuICAgIHN0cmluZyB8XG4gICAgYm9vbGVhbiB8XG4gICAgQmFzZUdhbWVPYmplY3QgfFxuICAgIG51bGwgfFxuICAgIHVuZGVmaW5lZFxuO1xuXG4vKiogQWxsIHNlcmlhYmxpYWJsZSB0eXBlcyAqL1xudHlwZSBTZXJpYWxpemFibGUgPVxuICAgIEJhc2VTZXJpYWxpemFibGUgfFxuICAgIFR5cGVkT2JqZWN0PEJhc2VTZXJpYWxpemFibGU+IHxcbiAgICBNYXA8c3RyaW5nLCBCYXNlU2VyaWFsaXphYmxlPiB8XG4gICAgQmFzZVNlcmlhbGl6YWJsZVtdXG47XG5cbi8qKiBCYXNlIHR5cGVzIHRoYXQgYXJlIHNlcmlhbGl6ZWQgdG8gKi9cbnR5cGUgQmFzZVNlcmlhbGl6ZWQgPVxuICAgIHN0cmluZyB8XG4gICAgbnVtYmVyIHxcbiAgICBib29sZWFuIHxcbiAgICBudWxsIHxcbiAgICB1bmRlZmluZWRcbjtcblxuLyoqIEFsbCB0eXBlcyB0aGF0IGFyZSBzZXJpYWxpemVkIHRvICovXG50eXBlIFNlcmlhbGl6ZWQgPVxuICAgIEJhc2VTZXJpYWxpemVkIHxcbiAgICBCYXNlU2VyaWFsaXplZFtdIHxcbiAgICBUeXBlZE9iamVjdDxCYXNlU2VyaWFsaXplZD5cbjtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBvYmplY3QgaXMgYSBnYW1lIG9iamVjdCByZWZlcmVuY2UgKGhhcyBvbmx5IGFuIGlkIGtleSBzZXQpLlxuICpcbiAqIEBwYXJhbSBvYmogLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgZ2FtZSBvYmplY3QgcmVmZXJlbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0dhbWVPYmplY3RSZWZlcmVuY2UoXG4gICAgb2JqOiBJbW11dGFibGU8VW5rbm93bk9iamVjdD4sXG4pOiBvYmogaXMge1xuICAgIC8qKiBUaGUgSUQgb2YgdGhpcyBHYW1lT2JqZWN0IGJlaW5nIHJlZmVyZW5jZWQuICovXG4gICAgaWQ6IHN0cmluZztcbn0ge1xuICAgIHJldHVybiBpc0VtcHR5RXhjZXB0Rm9yKG9iaiwgXCJpZFwiKTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemVzIHNvbWV0aGluZyBhYm91dCBhIGdhbWUgc28gaXQgaXMgc2FmZSB0byBzZW5kIG92ZXIgYSBzb2NrZXQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIHRvIGF2b2lkIGN5Y2xlcyBhbmQgc2VuZCBsaXN0cyBjb3JyZWN0bHkuXG4gKlxuICogQHBhcmFtIHN0YXRlIFRoZSB2YXJpYWJsZSB5b3Ugd2FudCB0byBzZXJpYWxpemUuXG4gKiBBbnl0aGluZyBpbiB0aGUgZ2FtZSBzaG91bGQgYmUgU2VyaWFsaXphYmxlLCBudW1iZXJzLCBzdHJpbmdzLFxuICogQmFzZUdhbWVPYmplY3RzLCBkaWN0cywgbGlzdHMsIG51bGxzLCBldGMuXG4gKiBAcmV0dXJucyBUaGUgc3RhdGUsIHNlcmlhbGl6ZWQuIEl0IHdpbGwgbmV2ZXIgYmUgdGhlIHNhbWUgb2JqZWN0IGlmIGl0IGlzIGFuXG4gKiBvYmplY3QgKHt9IG9yIFtdKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShzdGF0ZTogdW5rbm93bik6IFNlcmlhbGl6ZWQge1xuICAgIGxldCBzZXJpYWxpemluZyA9IHN0YXRlO1xuICAgIGlmICghaXNPYmplY3Qoc2VyaWFsaXppbmcpKSB7XG4gICAgICAgIC8vIG5vdCBhbiBvYmplY3QsIG5vIG5lZWQgdG8gZnVydGhlciBzZXJpYWxpemVcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6aW5nIGFzIEJhc2VTZXJpYWxpemVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZXJpYWxpemluZyBpbnN0YW5jZW9mIEJhc2VHYW1lT2JqZWN0KSB7XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gc2VyaWFsaXplIHRoaXMgd2hvbGUgdGhpbmdcbiAgICAgICAgcmV0dXJuIHsgaWQ6IHNlcmlhbGl6aW5nLmlkIH07XG4gICAgfVxuXG4gICAgaWYgKHNlcmlhbGl6aW5nIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHNlcmlhbGl6aW5nID0gbWFwVG9PYmplY3Qoc2VyaWFsaXppbmcpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcmlhbGl6ZWQ6IFVua25vd25PYmplY3QgPSB7fTtcbiAgICBpZiAoc2VyaWFsaXppbmcgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAvLyBSZWNvcmQgdGhlIGxlbmd0aCwgd2UgbmV2ZXIgc2VuZCBhcnJheXMgaW4gc2VyaWFsaXplZCBzdGF0ZXMgYmVjYXVzZVxuICAgICAgICAvLyB5b3UgY2FuJ3QgdGVsbCB3aGVuIHRoZXkgY2hhbmdlIGluIHNpemUgd2l0aG91dCBzZW5kaW5nIGFsbCB0aGVcbiAgICAgICAgLy8gZWxlbWVudHMuXG4gICAgICAgIHNlcmlhbGl6ZWRbU0hBUkVEX0NPTlNUQU5UUy5ERUxUQV9MSVNUX0xFTkdUSF0gPSBzZXJpYWxpemluZy5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2VyaWFsaXppbmcgYXMgVW5rbm93bk9iamVjdCkpIHtcbiAgICAgICAgc2VyaWFsaXplZFtrZXldID0gc2VyaWFsaXplKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VyaWFsaXplZCBhcyB7fTsgLy8gaXQgaXMgYWN0dWFsbHkgVHlwZWRPYmplY3Q8U2VyaWFsaXplZD4gYnV0IHRoYXQgZ2V0cyBtYWRcbn1cblxuLyoqXG4gKiBVbi1zZXJpYWxpemVzIGRhdGEgZnJvbSBhIGdhbWUgY2xpZW50LlxuICpcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIHVuLXNlcmlhbGl6ZS5cbiAqIEBwYXJhbSBnYW1lIFRoZSBnYW1lIHRvIGxvb2t1cCBnYW1lIG9iamVjdHMgaW4gZm9yIGdhbWUgb2JqZWN0IHJlZmVyZW5jZXMgaW5cbiAqIGRhdGEuXG4gKiBAcGFyYW0gZGF0YVR5cGVDb252ZXJ0ZXIgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQgdGhlIHVuLXNlcmlhbGl6ZWQgdmFsdWVcbiAqIG9uY2UgZm91bmQuXG4gKiBAcmV0dXJucyBUaGUgZGF0YSBub3cgdW4tc2VyaWFsaXplZCwgd2lsbCBjcmVhdGUgbmV3IG9iamVjdHMgaW5zdGVhZCBvZlxuICogcmV1c2luZyBvYmplY3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5TZXJpYWxpemU8VCA9IFNlcmlhbGl6YWJsZT4oXG4gICAgZGF0YTogdW5rbm93bixcbiAgICBnYW1lOiBCYXNlR2FtZSxcbiAgICBkYXRhVHlwZUNvbnZlcnRlcj86ICh2YWw6IHVua25vd24pID0+IFQsXG4pOiBUIHtcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkgJiYgZ2FtZSkge1xuICAgICAgICBjb25zdCByZXN1bHQ6IFVua25vd25PYmplY3QgPSBBcnJheS5pc0FycmF5KGRhdGEpXG4gICAgICAgICAgICA/IFtdIGFzIHt9IC8vIG51bWJlcnMgYXJlIGltcGxpY2l0bHkgY29udmVydGVkIHRvIHN0cmluZ3Mgd2hpY2ggd29ya3MsIGtpbmRhIGhhY2steVxuICAgICAgICAgICAgOiB7fTtcblxuICAgICAgICBmb3IgKGNvbnN0IFsga2V5LCB2YWx1ZSBdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBpc0dhbWVPYmplY3RSZWZlcmVuY2UodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgID8gZ2FtZS5nYW1lT2JqZWN0c1t2YWx1ZS5pZF0gLy8gaXQncyBhIHRyYWNrZWQgZ2FtZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgOiB1blNlcmlhbGl6ZSh2YWx1ZSwgZ2FtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdCBhcyB1bmtub3duIGFzIFQ7XG4gICAgfVxuXG4gICAgaWYgKGRhdGFUeXBlQ29udmVydGVyKSB7XG4gICAgICAgIHJldHVybiBkYXRhVHlwZUNvbnZlcnRlcihkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YSBhcyBUOyAvLyBpdCBpcyBhIHByaW1pdGl2ZSwgd2hpY2ggYXJlIHNlcmlhbGl6ZWFibGVcbn1cbiJdfQ==