"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require("./");
// <<-- Creer-Merge: imports -->>
const utils_1 = require("~/utils");
const DIRECTIONAL_OFFSETS = {
    North: { x: 0, y: -1 },
    East: { x: 1, y: 0 },
    South: { x: 0, y: 1 },
    West: { x: -1, y: 0 },
};
function pointToKey(pt) {
    return `${pt.x},${pt.y}`;
}
function keyToPoint(str) {
    const split = str.split(",");
    return {
        x: Number(split[0]),
        y: Number(split[1]),
    };
}
// <<-- /Creer-Merge: imports -->>
/**
 * Two player grid based game where each player tries to burn down the other
 * player's buildings. Let it burn.
 */
class AnarchyGame extends _1.BaseClasses.Game {
    // <<-- /Creer-Merge: attributes -->>
    /**
     * Called when a Game is created.
     *
     * @param settingsManager - The manager that holds initial settings.
     * @param required - Data required to initialize this (ignore it).
     */
    constructor(settingsManager, required) {
        super(settingsManager, required);
        this.settingsManager = settingsManager;
        /** The settings used to initialize the game, as set by players */
        this.settings = Object.freeze(this.settingsManager.values);
        // <<-- Creer-Merge: attributes -->>
        /** A handy 2D grid of all the buildings. */
        this.buildingsGrid = utils_1.make2D(this.mapWidth, this.mapHeight);
        /** The valid cardinal directions buildings can be in. */
        this.directions = [
            "North",
            "East",
            "South",
            "West",
        ];
        // <<-- Creer-Merge: constructor -->>
        const MIN_NUM_POINTS = 8;
        const MAX_NUM_POINTS = 15;
        const NUM_POINTS = this.manager.random.int(MAX_NUM_POINTS, MIN_NUM_POINTS);
        const MIN_EDGE_POINTS = 1;
        const MAX_EDGE_POINTS = 5;
        const EDGE_POINTS = this.manager.random.int(MAX_EDGE_POINTS, MIN_EDGE_POINTS);
        const pointsSet = new Set();
        // add random points (regular and edge points)
        for (let i = 0; i < NUM_POINTS + EDGE_POINTS; i++) {
            const x = i < NUM_POINTS
                ? this.manager.random.int(this.mapWidth / 2 - 1, 0)
                : this.mapWidth / 2 - 1;
            const y = this.manager.random.int(this.mapHeight - 1, 0);
            pointsSet.add(pointToKey({ x, y }));
        }
        // now connect the points, after shuffling them
        const points = Array.from(pointsSet);
        this.manager.random.shuffle(points);
        const startingLength = points.length;
        for (let i = 0; i < startingLength; i++) {
            let from = keyToPoint(points[i]);
            const to = keyToPoint(points[i + 1]);
            while (true) {
                const changes = [];
                // Is there a better way to do this?
                if (from.x < to.x) {
                    changes.push({ x: 1, y: 0 });
                }
                else if (from.x > to.x) {
                    changes.push({ x: -1, y: 0 });
                }
                if (from.y < to.y) {
                    changes.push({ x: 0, y: 1 });
                }
                else if (from.y > to.y) {
                    changes.push({ x: 0, y: -1 });
                }
                // this means that the point has already been reached
                // so break from the loop
                if (!utils_1.arrayHasElements(changes)) {
                    break;
                }
                // otherwise choose a random direction and add it to the
                // points
                const change = this.manager.random.element(changes);
                const connectedPoint = {
                    x: from.x + change.x,
                    y: from.y + change.y,
                };
                from = connectedPoint;
                points.push(pointToKey(connectedPoint));
            }
        }
        this.manager.random.shuffle(points);
        const buildingTypes = ["Warehouse", "FireDepartment", "PoliceDepartment", "WeatherStation"];
        const buildingsByWeight = new Map();
        buildingsByWeight.set("Warehouse", 0.40);
        buildingsByWeight.set("FireDepartment", 0.30);
        buildingsByWeight.set("PoliceDepartment", 0.20);
        buildingsByWeight.set("WeatherStation", 0.10);
        const minimumBuildingsPerType = 2;
        const originalBuildings = [];
        let madeHQ = false;
        for (let i = 0; i < points.length; i++) {
            let buildingType = buildingTypes[i % buildingTypes.length];
            if (i >= minimumBuildingsPerType * buildingTypes.length) {
                // then we have the minimum number of buildings we want, so now
                // introduce some random-ness
                buildingType = this.manager.random.fromWeights(buildingsByWeight);
            }
            let isHeadquarters = false;
            if (!madeHQ && buildingType === "Warehouse") {
                isHeadquarters = true;
                madeHQ = true;
            }
            if (!utils_1.arrayHasElements(this.players)) {
                throw new Error("No players in Anarchy game!");
            }
            const { x, y } = keyToPoint(points[i]);
            originalBuildings.push(this.manager.createBuilding(buildingType, {
                x,
                y,
                isHeadquarters,
                owner: this.manager.random.element(this.players),
            }));
        }
        // mirror the map
        for (const originalBuilding of originalBuildings) {
            this.manager.createBuilding(originalBuilding.gameObjectName, {
                x: this.mapWidth - originalBuilding.x - 1,
                y: originalBuilding.y,
                owner: originalBuilding.owner.opponent,
                isHeadquarters: originalBuilding.isHeadquarters,
            });
        }
        // now all the buildings on the map should be created, so hook up the north/east/south/west pointers
        for (const building of this.buildings) {
            for (const [direction, offset] of Object.entries(DIRECTIONAL_OFFSETS)) {
                // tslint:disable-next-line:no-any no-unsafe-any - any other way would be stupid over complex
                building[`building${direction}`] = this.getBuildingAt(building.x + offset.x, building.y + offset.y);
            }
        }
        // create the forecasts, each "set" of turns (e.g. 0 and 1, 100 and 101,
        // 264 and 265, etc) are the same initial states for each player.
        for (let i = 0; i < this.maxTurns; i += 2) {
            let direction = this.manager.random.element(this.directions);
            const intensity = this.manager.random.int(this.maxForecastIntensity);
            for (let j = 0; j < 2; j++) {
                if (j === 1) { // for the second player's forecasts mirror the directions East/West
                    if (direction === "East") {
                        direction = "West";
                    }
                    else if (direction === "West") {
                        direction = "East";
                    }
                }
                direction = direction || "North";
                this.forecasts.push(this.manager.create.forecast({
                    direction,
                    intensity,
                    controllingPlayer: this.players[j],
                }));
            }
        }
        this.currentForecast = this.forecasts[0];
        this.nextForecast = this.forecasts[1];
        // <<-- /Creer-Merge: constructor -->>
    }
    // <<-- Creer-Merge: public-functions -->>
    /**
     * Gets a building at a specified (x, y).
     *
     * @param x - The x coordinate.
     * @param y - The y coordinate.
     * @returns The building at (x, y), or undefined if there is none.
     */
    getBuildingAt(x, y) {
        if (x >= 0 && y >= 0 && x < this.mapWidth && y < this.mapHeight) {
            return this.buildingsGrid[x][y];
        }
    }
}
exports.AnarchyGame = AnarchyGame;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2FtZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9nYW1lcy9hbmFyY2h5L2dhbWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFDQSx5QkFBaUM7QUFRakMsaUNBQWlDO0FBQ2pDLG1DQUEyRDtBQUUzRCxNQUFNLG1CQUFtQixHQUFHO0lBQ3hCLEtBQUssRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFO0lBQ3RCLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUNwQixLQUFLLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7SUFDckIsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7Q0FDeEIsQ0FBQztBQUVGLFNBQVMsVUFBVSxDQUFDLEVBQVU7SUFDMUIsT0FBTyxHQUFHLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDO0FBQzdCLENBQUM7QUFFRCxTQUFTLFVBQVUsQ0FBQyxHQUFXO0lBQzNCLE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFN0IsT0FBTztRQUNILENBQUMsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25CLENBQUMsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3RCLENBQUM7QUFDTixDQUFDO0FBRUQsa0NBQWtDO0FBRWxDOzs7R0FHRztBQUNILE1BQWEsV0FBWSxTQUFRLGNBQVcsQ0FBQyxJQUFJO0lBMEc3QyxxQ0FBcUM7SUFFckM7Ozs7O09BS0c7SUFDSCxZQUNjLGVBQTJDLEVBQ3JELFFBQXlDO1FBRXpDLEtBQUssQ0FBQyxlQUFlLEVBQUUs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Q0FBc0M7SUFDMUMsQ0FBQztJQUVELDBDQUEwQztJQUUxQzs7Ozs7O09BTUc7SUFDSSxhQUFhLENBQUMsQ0FBUyxFQUFFLENBQVM7UUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDN0QsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ25DO0lBQ0wsQ0FBQztDQVNKO0FBMVNELGtDQTBTQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElCYXNlR2FtZVJlcXVpcmVkRGF0YSB9IGZyb20gXCJ+L2NvcmUvZ2FtZVwiO1xuaW1wb3J0IHsgQmFzZUNsYXNzZXMgfSBmcm9tIFwiLi9cIjtcbmltcG9ydCB7IEJ1aWxkaW5nIH0gZnJvbSBcIi4vYnVpbGRpbmdcIjtcbmltcG9ydCB7IEZvcmVjYXN0IH0gZnJvbSBcIi4vZm9yZWNhc3RcIjtcbmltcG9ydCB7IEFuYXJjaHlHYW1lTWFuYWdlciB9IGZyb20gXCIuL2dhbWUtbWFuYWdlclwiO1xuaW1wb3J0IHsgR2FtZU9iamVjdCB9IGZyb20gXCIuL2dhbWUtb2JqZWN0XCI7XG5pbXBvcnQgeyBBbmFyY2h5R2FtZVNldHRpbmdzTWFuYWdlciB9IGZyb20gXCIuL2dhbWUtc2V0dGluZ3NcIjtcbmltcG9ydCB7IFBsYXllciB9IGZyb20gXCIuL3BsYXllclwiO1xuXG4vLyA8PC0tIENyZWVyLU1lcmdlOiBpbXBvcnRzIC0tPj5cbmltcG9ydCB7IGFycmF5SGFzRWxlbWVudHMsIElQb2ludCwgbWFrZTJEIH0gZnJvbSBcIn4vdXRpbHNcIjtcblxuY29uc3QgRElSRUNUSU9OQUxfT0ZGU0VUUyA9IHtcbiAgICBOb3J0aDogeyB4OiAwLCB5OiAtMSB9LFxuICAgIEVhc3Q6IHsgeDogMSwgeTogMCB9LFxuICAgIFNvdXRoOiB7IHg6IDAsIHk6IDEgfSxcbiAgICBXZXN0OiB7IHg6IC0xLCB5OiAwIH0sXG59O1xuXG5mdW5jdGlvbiBwb2ludFRvS2V5KHB0OiBJUG9pbnQpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHtwdC54fSwke3B0Lnl9YDtcbn1cblxuZnVuY3Rpb24ga2V5VG9Qb2ludChzdHI6IHN0cmluZyk6IElQb2ludCB7XG4gICAgY29uc3Qgc3BsaXQgPSBzdHIuc3BsaXQoXCIsXCIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogTnVtYmVyKHNwbGl0WzBdKSxcbiAgICAgICAgeTogTnVtYmVyKHNwbGl0WzFdKSxcbiAgICB9O1xufVxuXG4vLyA8PC0tIC9DcmVlci1NZXJnZTogaW1wb3J0cyAtLT4+XG5cbi8qKlxuICogVHdvIHBsYXllciBncmlkIGJhc2VkIGdhbWUgd2hlcmUgZWFjaCBwbGF5ZXIgdHJpZXMgdG8gYnVybiBkb3duIHRoZSBvdGhlclxuICogcGxheWVyJ3MgYnVpbGRpbmdzLiBMZXQgaXQgYnVybi5cbiAqL1xuZXhwb3J0IGNsYXNzIEFuYXJjaHlHYW1lIGV4dGVuZHMgQmFzZUNsYXNzZXMuR2FtZSB7XG4gICAgLyoqIFRoZSBtYW5hZ2VyIG9mIHRoaXMgZ2FtZSwgdGhhdCBjb250cm9scyBldmVyeXRoaW5nIGFyb3VuZCBpdCAqL1xuICAgIHB1YmxpYyByZWFkb25seSBtYW5hZ2VyITogQW5hcmNoeUdhbWVNYW5hZ2VyO1xuXG4gICAgLyoqIFRoZSBzZXR0aW5ncyB1c2VkIHRvIGluaXRpYWxpemUgdGhlIGdhbWUsIGFzIHNldCBieSBwbGF5ZXJzICovXG4gICAgcHVibGljIHJlYWRvbmx5IHNldHRpbmdzID0gT2JqZWN0LmZyZWV6ZSh0aGlzLnNldHRpbmdzTWFuYWdlci52YWx1ZXMpO1xuXG4gICAgLyoqXG4gICAgICogSG93IG1hbnkgYnJpYmVzIHBsYXllcnMgZ2V0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlaXIgdHVybiwgbm90IGNvdW50aW5nXG4gICAgICogdGhlaXIgYnVybmVkIGRvd24gQnVpbGRpbmdzLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBiYXNlQnJpYmVzUGVyVHVybiE6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEFsbCB0aGUgYnVpbGRpbmdzIGluIHRoZSBnYW1lLlxuICAgICAqL1xuICAgIHB1YmxpYyBidWlsZGluZ3MhOiBCdWlsZGluZ1tdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgRm9yZWNhc3QsIHdoaWNoIHdpbGwgYmUgYXBwbGllZCBhdCB0aGUgZW5kIG9mIHRoZSB0dXJuLlxuICAgICAqL1xuICAgIHB1YmxpYyBjdXJyZW50Rm9yZWNhc3Q6IEZvcmVjYXN0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBsYXllciB3aG9zZSB0dXJuIGl0IGlzIGN1cnJlbnRseS4gVGhhdCBwbGF5ZXIgY2FuIHNlbmQgY29tbWFuZHMuXG4gICAgICogT3RoZXIgcGxheWVycyBjYW5ub3QuXG4gICAgICovXG4gICAgcHVibGljIGN1cnJlbnRQbGF5ZXIhOiBQbGF5ZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCB0dXJuIG51bWJlciwgc3RhcnRpbmcgYXQgMCBmb3IgdGhlIGZpcnN0IHBsYXllcidzIHR1cm4uXG4gICAgICovXG4gICAgcHVibGljIGN1cnJlbnRUdXJuITogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQWxsIHRoZSBmb3JlY2FzdHMgaW4gdGhlIGdhbWUsIGluZGV4ZWQgYnkgdHVybiBudW1iZXIuXG4gICAgICovXG4gICAgcHVibGljIGZvcmVjYXN0cyE6IEZvcmVjYXN0W107XG5cbiAgICAvKipcbiAgICAgKiBBIG1hcHBpbmcgb2YgZXZlcnkgZ2FtZSBvYmplY3QncyBJRCB0byB0aGUgYWN0dWFsIGdhbWUgb2JqZWN0LiBQcmltYXJpbHlcbiAgICAgKiB1c2VkIGJ5IHRoZSBzZXJ2ZXIgYW5kIGNsaWVudCB0byBlYXNpbHkgcmVmZXIgdG8gdGhlIGdhbWUgb2JqZWN0cyB2aWFcbiAgICAgKiBJRC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2FtZU9iamVjdHMhOiB7W2lkOiBzdHJpbmddOiBHYW1lT2JqZWN0fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgZW50aXJlIG1hcCBhbG9uZyB0aGUgdmVydGljYWwgKHkpIGF4aXMuXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IG1hcEhlaWdodCE6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgZW50aXJlIG1hcCBhbG9uZyB0aGUgaG9yaXpvbnRhbCAoeCkgYXhpcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgbWFwV2lkdGghOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBhbW91bnQgb2YgZmlyZSB2YWx1ZSBmb3IgYW55IEJ1aWxkaW5nLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBtYXhGaXJlITogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIGludGVuc2l0eSB2YWx1ZSBmb3IgYW55IEZvcmVjYXN0LlxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBtYXhGb3JlY2FzdEludGVuc2l0eSE6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0dXJucyBiZWZvcmUgdGhlIGdhbWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgbWF4VHVybnMhOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmV4dCBGb3JlY2FzdCwgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIGF0IHRoZSBlbmQgb2YgeW91ciBvcHBvbmVudCdzXG4gICAgICogdHVybi4gVGhpcyBpcyBhbHNvIHRoZSBGb3JlY2FzdCBXZWF0aGVyU3RhdGlvbnMgY2FuIGNvbnRyb2wgdGhpcyB0dXJuLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZXh0Rm9yZWNhc3Q/OiBGb3JlY2FzdDtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYWxsIHRoZSBwbGF5ZXJzIGluIHRoZSBnYW1lLlxuICAgICAqL1xuICAgIHB1YmxpYyBwbGF5ZXJzITogUGxheWVyW107XG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZ2FtZSBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIHBsYXllZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgc2Vzc2lvbiE6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgb2YgdGltZSAoaW4gbmFuby1zZWNvbmRzKSBhZGRlZCBhZnRlciBlYWNoIHBsYXllciBwZXJmb3JtcyBhXG4gICAgICogdHVybi5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgdGltZUFkZGVkUGVyVHVybiE6IG51bWJlcjtcblxuICAgIC8vIDw8LS0gQ3JlZXItTWVyZ2U6IGF0dHJpYnV0ZXMgLS0+PlxuXG4gICAgLyoqIEEgaGFuZHkgMkQgZ3JpZCBvZiBhbGwgdGhlIGJ1aWxkaW5ncy4gKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgYnVpbGRpbmdzR3JpZCA9IG1ha2UyRDxCdWlsZGluZz4odGhpcy5tYXBXaWR0aCwgdGhpcy5tYXBIZWlnaHQpO1xuXG4gICAgLyoqIFRoZSB2YWxpZCBjYXJkaW5hbCBkaXJlY3Rpb25zIGJ1aWxkaW5ncyBjYW4gYmUgaW4uICovXG4gICAgcHVibGljIHJlYWRvbmx5IGRpcmVjdGlvbnM6IFtcIk5vcnRoXCIsIFwiRWFzdFwiLCBcIlNvdXRoXCIsIFwiV2VzdFwiXSA9IFtcbiAgICAgICAgXCJOb3J0aFwiLFxuICAgICAgICBcIkVhc3RcIixcbiAgICAgICAgXCJTb3V0aFwiLFxuICAgICAgICBcIldlc3RcIixcbiAgICBdO1xuXG4gICAgLy8gPDwtLSAvQ3JlZXItTWVyZ2U6IGF0dHJpYnV0ZXMgLS0+PlxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBHYW1lIGlzIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2V0dGluZ3NNYW5hZ2VyIC0gVGhlIG1hbmFnZXIgdGhhdCBob2xkcyBpbml0aWFsIHNldHRpbmdzLlxuICAgICAqIEBwYXJhbSByZXF1aXJlZCAtIERhdGEgcmVxdWlyZWQgdG8gaW5pdGlhbGl6ZSB0aGlzIChpZ25vcmUgaXQpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcm90ZWN0ZWQgc2V0dGluZ3NNYW5hZ2VyOiBBbmFyY2h5R2FtZVNldHRpbmdzTWFuYWdlcixcbiAgICAgICAgcmVxdWlyZWQ6IFJlYWRvbmx5PElCYXNlR2FtZVJlcXVpcmVkRGF0YT4sXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmdzTWFuYWdlciwgcmVxdWlyZWQpO1xuXG4gICAgICAgIC8vIDw8LS0gQ3JlZXItTWVyZ2U6IGNvbnN0cnVjdG9yIC0tPj5cblxuICAgICAgICBjb25zdCBNSU5fTlVNX1BPSU5UUyA9IDg7XG4gICAgICAgIGNvbnN0IE1BWF9OVU1fUE9JTlRTID0gMTU7XG4gICAgICAgIGNvbnN0IE5VTV9QT0lOVFMgPSB0aGlzLm1hbmFnZXIucmFuZG9tLmludChNQVhfTlVNX1BPSU5UUywgTUlOX05VTV9QT0lOVFMpO1xuXG4gICAgICAgIGNvbnN0IE1JTl9FREdFX1BPSU5UUyA9IDE7XG4gICAgICAgIGNvbnN0IE1BWF9FREdFX1BPSU5UUyA9IDU7XG4gICAgICAgIGNvbnN0IEVER0VfUE9JTlRTID0gdGhpcy5tYW5hZ2VyLnJhbmRvbS5pbnQoTUFYX0VER0VfUE9JTlRTLCBNSU5fRURHRV9QT0lOVFMpO1xuICAgICAgICBjb25zdCBwb2ludHNTZXQgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgICAgICAvLyBhZGQgcmFuZG9tIHBvaW50cyAocmVndWxhciBhbmQgZWRnZSBwb2ludHMpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlVNX1BPSU5UUyArIEVER0VfUE9JTlRTOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBpIDwgTlVNX1BPSU5UU1xuICAgICAgICAgICAgICAgID8gdGhpcy5tYW5hZ2VyLnJhbmRvbS5pbnQodGhpcy5tYXBXaWR0aCAvIDIgLSAxLCAwKVxuICAgICAgICAgICAgICAgIDogdGhpcy5tYXBXaWR0aCAvIDIgLSAxO1xuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMubWFuYWdlci5yYW5kb20uaW50KHRoaXMubWFwSGVpZ2h0IC0gMSwgMCk7XG5cbiAgICAgICAgICAgIHBvaW50c1NldC5hZGQocG9pbnRUb0tleSh7eCwgeX0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdyBjb25uZWN0IHRoZSBwb2ludHMsIGFmdGVyIHNodWZmbGluZyB0aGVtXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IEFycmF5LmZyb20ocG9pbnRzU2V0KTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJhbmRvbS5zaHVmZmxlKHBvaW50cyk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRpbmdMZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJ0aW5nTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBmcm9tOiBJUG9pbnQgPSBrZXlUb1BvaW50KHBvaW50c1tpXSk7XG4gICAgICAgICAgICBjb25zdCB0bzogSVBvaW50ID0ga2V5VG9Qb2ludChwb2ludHNbaSArIDFdKTtcblxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VzOiBJUG9pbnRbXSA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIElzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzP1xuICAgICAgICAgICAgICAgIGlmIChmcm9tLnggPCB0by54KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IHg6IDEsIHk6IDAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZyb20ueCA+IHRvLngpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgeDogLTEsIHk6IDAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcm9tLnkgPCB0by55KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IHg6IDAsIHk6IDEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZyb20ueSA+IHRvLnkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgeDogMCwgeTogLTEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCB0aGUgcG9pbnQgaGFzIGFscmVhZHkgYmVlbiByZWFjaGVkXG4gICAgICAgICAgICAgICAgLy8gc28gYnJlYWsgZnJvbSB0aGUgbG9vcFxuICAgICAgICAgICAgICAgIGlmICghYXJyYXlIYXNFbGVtZW50cyhjaGFuZ2VzKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBhIHJhbmRvbSBkaXJlY3Rpb24gYW5kIGFkZCBpdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBwb2ludHNcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSB0aGlzLm1hbmFnZXIucmFuZG9tLmVsZW1lbnQoY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGVkUG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGZyb20ueCArIGNoYW5nZS54LFxuICAgICAgICAgICAgICAgICAgICB5OiBmcm9tLnkgKyBjaGFuZ2UueSxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZnJvbSA9IGNvbm5lY3RlZFBvaW50O1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50VG9LZXkoY29ubmVjdGVkUG9pbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hbmFnZXIucmFuZG9tLnNodWZmbGUocG9pbnRzKTtcblxuICAgICAgICBjb25zdCBidWlsZGluZ1R5cGVzID0gW1wiV2FyZWhvdXNlXCIsIFwiRmlyZURlcGFydG1lbnRcIiwgXCJQb2xpY2VEZXBhcnRtZW50XCIsIFwiV2VhdGhlclN0YXRpb25cIl07XG4gICAgICAgIGNvbnN0IGJ1aWxkaW5nc0J5V2VpZ2h0ID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgICAgICAgYnVpbGRpbmdzQnlXZWlnaHQuc2V0KFwiV2FyZWhvdXNlXCIsIDAuNDApO1xuICAgICAgICBidWlsZGluZ3NCeVdlaWdodC5zZXQoXCJGaXJlRGVwYXJ0bWVudFwiLCAwLjMwKTtcbiAgICAgICAgYnVpbGRpbmdzQnlXZWlnaHQuc2V0KFwiUG9saWNlRGVwYXJ0bWVudFwiLCAwLjIwKTtcbiAgICAgICAgYnVpbGRpbmdzQnlXZWlnaHQuc2V0KFwiV2VhdGhlclN0YXRpb25cIiwgMC4xMCk7XG5cbiAgICAgICAgY29uc3QgbWluaW11bUJ1aWxkaW5nc1BlclR5cGUgPSAyO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEJ1aWxkaW5ncyA9IFtdO1xuXG4gICAgICAgIGxldCBtYWRlSFEgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBidWlsZGluZ1R5cGUgPSBidWlsZGluZ1R5cGVzW2kgJSBidWlsZGluZ1R5cGVzLmxlbmd0aF07XG4gICAgICAgICAgICBpZiAoaSA+PSBtaW5pbXVtQnVpbGRpbmdzUGVyVHlwZSAqIGJ1aWxkaW5nVHlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBoYXZlIHRoZSBtaW5pbXVtIG51bWJlciBvZiBidWlsZGluZ3Mgd2Ugd2FudCwgc28gbm93XG4gICAgICAgICAgICAgICAgLy8gaW50cm9kdWNlIHNvbWUgcmFuZG9tLW5lc3NcblxuICAgICAgICAgICAgICAgIGJ1aWxkaW5nVHlwZSA9IHRoaXMubWFuYWdlci5yYW5kb20uZnJvbVdlaWdodHMoYnVpbGRpbmdzQnlXZWlnaHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaXNIZWFkcXVhcnRlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghbWFkZUhRICYmIGJ1aWxkaW5nVHlwZSA9PT0gXCJXYXJlaG91c2VcIikge1xuICAgICAgICAgICAgICAgIGlzSGVhZHF1YXJ0ZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtYWRlSFEgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWFycmF5SGFzRWxlbWVudHModGhpcy5wbGF5ZXJzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHBsYXllcnMgaW4gQW5hcmNoeSBnYW1lIVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBrZXlUb1BvaW50KHBvaW50c1tpXSk7XG4gICAgICAgICAgICBvcmlnaW5hbEJ1aWxkaW5ncy5wdXNoKHRoaXMubWFuYWdlci5jcmVhdGVCdWlsZGluZyhidWlsZGluZ1R5cGUsIHtcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgaXNIZWFkcXVhcnRlcnMsXG4gICAgICAgICAgICAgICAgb3duZXI6IHRoaXMubWFuYWdlci5yYW5kb20uZWxlbWVudCh0aGlzLnBsYXllcnMpLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWlycm9yIHRoZSBtYXBcbiAgICAgICAgZm9yIChjb25zdCBvcmlnaW5hbEJ1aWxkaW5nIG9mIG9yaWdpbmFsQnVpbGRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuY3JlYXRlQnVpbGRpbmcob3JpZ2luYWxCdWlsZGluZy5nYW1lT2JqZWN0TmFtZSwge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMubWFwV2lkdGggLSBvcmlnaW5hbEJ1aWxkaW5nLnggLSAxLFxuICAgICAgICAgICAgICAgIHk6IG9yaWdpbmFsQnVpbGRpbmcueSxcbiAgICAgICAgICAgICAgICBvd25lcjogb3JpZ2luYWxCdWlsZGluZy5vd25lci5vcHBvbmVudCxcbiAgICAgICAgICAgICAgICBpc0hlYWRxdWFydGVyczogb3JpZ2luYWxCdWlsZGluZy5pc0hlYWRxdWFydGVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm93IGFsbCB0aGUgYnVpbGRpbmdzIG9uIHRoZSBtYXAgc2hvdWxkIGJlIGNyZWF0ZWQsIHNvIGhvb2sgdXAgdGhlIG5vcnRoL2Vhc3Qvc291dGgvd2VzdCBwb2ludGVyc1xuICAgICAgICBmb3IgKGNvbnN0IGJ1aWxkaW5nIG9mIHRoaXMuYnVpbGRpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtkaXJlY3Rpb24sIG9mZnNldF0gb2YgT2JqZWN0LmVudHJpZXMoRElSRUNUSU9OQUxfT0ZGU0VUUykpIHtcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55IG5vLXVuc2FmZS1hbnkgLSBhbnkgb3RoZXIgd2F5IHdvdWxkIGJlIHN0dXBpZCBvdmVyIGNvbXBsZXhcbiAgICAgICAgICAgICAgICAoYnVpbGRpbmcgYXMgYW55KVtgYnVpbGRpbmcke2RpcmVjdGlvbn1gXSA9IHRoaXMuZ2V0QnVpbGRpbmdBdChcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRpbmcueCArIG9mZnNldC54LFxuICAgICAgICAgICAgICAgICAgICBidWlsZGluZy55ICsgb2Zmc2V0LnksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgZm9yZWNhc3RzLCBlYWNoIFwic2V0XCIgb2YgdHVybnMgKGUuZy4gMCBhbmQgMSwgMTAwIGFuZCAxMDEsXG4gICAgICAgIC8vIDI2NCBhbmQgMjY1LCBldGMpIGFyZSB0aGUgc2FtZSBpbml0aWFsIHN0YXRlcyBmb3IgZWFjaCBwbGF5ZXIuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXhUdXJuczsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgZGlyZWN0aW9uID0gdGhpcy5tYW5hZ2VyLnJhbmRvbS5lbGVtZW50KHRoaXMuZGlyZWN0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBpbnRlbnNpdHkgPSB0aGlzLm1hbmFnZXIucmFuZG9tLmludCh0aGlzLm1heEZvcmVjYXN0SW50ZW5zaXR5KTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMSkgeyAvLyBmb3IgdGhlIHNlY29uZCBwbGF5ZXIncyBmb3JlY2FzdHMgbWlycm9yIHRoZSBkaXJlY3Rpb25zIEVhc3QvV2VzdFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBcIkVhc3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gXCJXZXN0XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcIldlc3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gXCJFYXN0XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBkaXJlY3Rpb24gfHwgXCJOb3J0aFwiO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JlY2FzdHMucHVzaCh0aGlzLm1hbmFnZXIuY3JlYXRlLmZvcmVjYXN0KHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBpbnRlbnNpdHksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsaW5nUGxheWVyOiB0aGlzLnBsYXllcnNbal0sXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXJyZW50Rm9yZWNhc3QgPSB0aGlzLmZvcmVjYXN0c1swXTtcbiAgICAgICAgdGhpcy5uZXh0Rm9yZWNhc3QgPSB0aGlzLmZvcmVjYXN0c1sxXTtcblxuICAgICAgICAvLyA8PC0tIC9DcmVlci1NZXJnZTogY29uc3RydWN0b3IgLS0+PlxuICAgIH1cblxuICAgIC8vIDw8LS0gQ3JlZXItTWVyZ2U6IHB1YmxpYy1mdW5jdGlvbnMgLS0+PlxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGJ1aWxkaW5nIGF0IGEgc3BlY2lmaWVkICh4LCB5KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB4IC0gVGhlIHggY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0geSAtIFRoZSB5IGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybnMgVGhlIGJ1aWxkaW5nIGF0ICh4LCB5KSwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vbmUuXG4gICAgICovXG4gICAgcHVibGljIGdldEJ1aWxkaW5nQXQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBCdWlsZGluZyB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGlmICh4ID49IDAgJiYgeSA+PSAwICYmIHggPCB0aGlzLm1hcFdpZHRoICYmIHkgPCB0aGlzLm1hcEhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRpbmdzR3JpZFt4XVt5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIDw8LS0gL0NyZWVyLU1lcmdlOiBwdWJsaWMtZnVuY3Rpb25zIC0tPj5cblxuICAgIC8vIDw8LS0gQ3JlZXItTWVyZ2U6IHByb3RlY3RlZC1wcml2YXRlLWZ1bmN0aW9ucyAtLT4+XG5cbiAgICAvLyBBbnkgYWRkaXRpb25hbCBwcm90ZWN0ZWQgb3IgcGlyYXRlIG1ldGhvZHMgY2FuIGdvIGhlcmUuXG5cbiAgICAvLyA8PC0tIC9DcmVlci1NZXJnZTogcHJvdGVjdGVkLXByaXZhdGUtZnVuY3Rpb25zIC0tPj5cbn1cbiJdfQ==